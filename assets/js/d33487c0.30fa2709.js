"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[5967],{5739:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module-01-ros2/week-5-control","title":"Week 5: ros2_control Framework","description":"Introduction to ros2_control","source":"@site/docs/module-01-ros2/week-5-control.md","sourceDirName":"module-01-ros2","slug":"/module-01-ros2/week-5-control","permalink":"/hackathon-book/module-01-ros2/week-5-control","draft":false,"unlisted":false,"editUrl":"https://github.com/Asmayaseen/hackathon-book/tree/main/frontend/docs/module-01-ros2/week-5-control.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Week 5: URDF for Humanoid Robots","permalink":"/hackathon-book/module-01-ros2/week-5-urdf"},"next":{"title":"Week 5: Complete Humanoid URDF Example","permalink":"/hackathon-book/module-01-ros2/week-5-complete-urdf"}}');var t=o(4848),i=o(8453);const a={},s="Week 5: ros2_control Framework",l={},c=[{value:"Introduction to ros2_control",id:"introduction-to-ros2_control",level:2},{value:"Why ros2_control?",id:"why-ros2_control",level:3},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"1. Hardware Interface",id:"1-hardware-interface",level:3},{value:"2. Controller Manager",id:"2-controller-manager",level:3},{value:"3. Controllers",id:"3-controllers",level:3},{value:"Controller Types for Humanoid Robots",id:"controller-types-for-humanoid-robots",level:2},{value:"Position Controllers",id:"position-controllers",level:3},{value:"Velocity Controllers",id:"velocity-controllers",level:3},{value:"Effort Controllers",id:"effort-controllers",level:3},{value:"ros2_control Configuration in URDF",id:"ros2_control-configuration-in-urdf",level:2},{value:"Hardware Interface Definition",id:"hardware-interface-definition",level:3},{value:"Controller Configuration YAML",id:"controller-configuration-yaml",level:3},{value:"Control Loop Basics",id:"control-loop-basics",level:2},{value:"1. Read State",id:"1-read-state",level:3},{value:"2. Update Controllers",id:"2-update-controllers",level:3},{value:"3. Write Commands",id:"3-write-commands",level:3},{value:"4. Repeat",id:"4-repeat",level:3},{value:"Launching ros2_control System",id:"launching-ros2_control-system",level:2},{value:"Testing Controllers",id:"testing-controllers",level:2},{value:"Hardware Interfaces for Real Robots",id:"hardware-interfaces-for-real-robots",level:2},{value:"Next Steps",id:"next-steps",level:2},{value:"Practice Exercise",id:"practice-exercise",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"week-5-ros2_control-framework",children:"Week 5: ros2_control Framework"})}),"\n",(0,t.jsx)(n.h2,{id:"introduction-to-ros2_control",children:"Introduction to ros2_control"}),"\n",(0,t.jsx)(n.p,{children:"The ros2_control framework provides a standardized architecture for robot control systems in ROS 2. It decouples controller algorithms from hardware-specific code through well-defined interfaces, enabling you to develop control strategies that work seamlessly across simulation and real robots."}),"\n",(0,t.jsx)(n.h3,{id:"why-ros2_control",children:"Why ros2_control?"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Hardware Abstraction"}),": Write controller code once, deploy to different actuator types (servo motors, hydraulic actuators, electric motors) by swapping hardware interface plugins."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Real-time Safety"}),": ros2_control runs controllers in dedicated threads with real-time priorities, ensuring deterministic execution\u2014critical for humanoid balance control where delays can cause falls."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Ecosystem Integration"}),": Compatible with MoveIt (motion planning), Gazebo (simulation), and industrial robot drivers. Humanoid projects benefit from reusing proven controller implementations."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"State Management"}),": Provides lifecycle management for controllers (inactive, active, emergency_stop), enabling safe mode transitions during operation."]}),"\n",(0,t.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,t.jsx)(n.p,{children:"ros2_control consists of three main components:"}),"\n",(0,t.jsx)(n.h3,{id:"1-hardware-interface",children:"1. Hardware Interface"}),"\n",(0,t.jsx)(n.p,{children:"Bridges between controller commands and physical/simulated hardware. Defines how to read sensor data (joint encoders, force sensors) and write actuator commands (motor voltages, position setpoints)."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Interface Types"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"CommandInterface"}),": Write commands to hardware (e.g., ",(0,t.jsx)(n.code,{children:"position"}),", ",(0,t.jsx)(n.code,{children:"velocity"}),", ",(0,t.jsx)(n.code,{children:"effort"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"StateInterface"}),": Read sensor data (e.g., ",(0,t.jsx)(n.code,{children:"position"}),", ",(0,t.jsx)(n.code,{children:"velocity"}),", ",(0,t.jsx)(n.code,{children:"effort"}),")"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"2-controller-manager",children:"2. Controller Manager"}),"\n",(0,t.jsx)(n.p,{children:"Manages controller lifecycle: loading, configuring, activating, deactivating. Ensures only one controller writes to each command interface (prevents conflicts)."}),"\n",(0,t.jsx)(n.h3,{id:"3-controllers",children:"3. Controllers"}),"\n",(0,t.jsx)(n.p,{children:"Implement control algorithms (PID, model predictive control, impedance control). ROS 2 provides standard controllers:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"JointTrajectoryController"}),": Executes smooth multi-joint trajectories"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"JointGroupPositionController"}),": Simple position commands for joint groups"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"DiffDriveController"}),": For mobile bases (wheeled humanoids)"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"controller-types-for-humanoid-robots",children:"Controller Types for Humanoid Robots"}),"\n",(0,t.jsx)(n.h3,{id:"position-controllers",children:"Position Controllers"}),"\n",(0,t.jsx)(n.p,{children:"Command desired joint angles. The hardware interface (or lower-level controller in the actuator) closes the control loop to achieve the target position."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use cases"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Reaching to a target pose (arm stretched forward)"}),"\n",(0,t.jsx)(n.li,{children:"Holding a static posture (standing still)"}),"\n",(0,t.jsx)(n.li,{children:"Playing back pre-recorded motions"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Limitations"}),": Cannot directly control contact forces\u2014problematic for tasks like grasping or balancing on compliant surfaces."]}),"\n",(0,t.jsx)(n.h3,{id:"velocity-controllers",children:"Velocity Controllers"}),"\n",(0,t.jsx)(n.p,{children:"Command desired joint velocities. Useful for continuous motions where exact position is less critical than smooth speed profiles."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use cases"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Walking with prescribed joint velocity profiles"}),"\n",(0,t.jsx)(n.li,{children:"Compliant motions that adapt to external forces"}),"\n",(0,t.jsx)(n.li,{children:"Teleoperation (joystick input maps to joint speeds)"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Limitations"}),": Position drift over time without feedback correction."]}),"\n",(0,t.jsx)(n.h3,{id:"effort-controllers",children:"Effort Controllers"}),"\n",(0,t.jsx)(n.p,{children:"Command desired joint torques/forces. Provides direct control over interaction forces\u2014essential for advanced humanoid behaviors."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use cases"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Impedance control for safe human-robot interaction"}),"\n",(0,t.jsx)(n.li,{children:"Force-based grasping (close gripper until target force detected)"}),"\n",(0,t.jsx)(n.li,{children:"Balance control using ankle/hip torques to regulate center of mass"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Challenges"}),": Requires accurate dynamic models and force/torque sensing. Most humanoid research operates in effort control mode."]}),"\n",(0,t.jsx)(n.h2,{id:"ros2_control-configuration-in-urdf",children:"ros2_control Configuration in URDF"}),"\n",(0,t.jsx)(n.p,{children:"To use ros2_control, add special tags to your URDF that define hardware interfaces and controllers."}),"\n",(0,t.jsx)(n.h3,{id:"hardware-interface-definition",children:"Hardware Interface Definition"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="humanoid">\n\n  \x3c!-- Include ros2_control Xacro macros --\x3e\n  <xacro:include filename="$(find ros2_control)/urdf/ros2_control.xacro"/>\n\n  \x3c!-- Define ros2_control hardware interface --\x3e\n  <ros2_control name="HumanoidRobotSystem" type="system">\n\n    \x3c!-- Hardware plugin (use Gazebo for simulation) --\x3e\n    <hardware>\n      <plugin>gazebo_ros2_control/GazeboSystem</plugin>\n    </hardware>\n\n    \x3c!-- Joint 1: Left shoulder pitch --\x3e\n    <joint name="left_shoulder_pitch">\n      \x3c!-- State interfaces: what sensors can read --\x3e\n      <state_interface name="position"/>\n      <state_interface name="velocity"/>\n      <state_interface name="effort"/>\n\n      \x3c!-- Command interfaces: what controllers can write --\x3e\n      <command_interface name="position">\n        \x3c!-- Optional: set initial command value --\x3e\n        <param name="initial_value">0.0</param>\n      </command_interface>\n      <command_interface name="effort"/>\n\n      \x3c!-- Joint limits (optional, can also read from URDF) --\x3e\n      <param name="min_position">-1.57</param>\n      <param name="max_position">1.57</param>\n      <param name="max_velocity">2.0</param>\n      <param name="max_effort">100.0</param>\n    </joint>\n\n    \x3c!-- Joint 2: Left shoulder roll --\x3e\n    <joint name="left_shoulder_roll">\n      <state_interface name="position"/>\n      <state_interface name="velocity"/>\n      <state_interface name="effort"/>\n      <command_interface name="position"/>\n      <command_interface name="effort"/>\n      <param name="min_position">-0.785</param>\n      <param name="max_position">0.785</param>\n    </joint>\n\n    \x3c!-- Joint 3: Left elbow --\x3e\n    <joint name="left_elbow">\n      <state_interface name="position"/>\n      <state_interface name="velocity"/>\n      <state_interface name="effort"/>\n      <command_interface name="position"/>\n      <command_interface name="effort"/>\n      <param name="min_position">0.0</param>\n      <param name="max_position">2.356</param>\n    </joint>\n\n    \x3c!-- Repeat for right arm and leg joints... --\x3e\n\n    \x3c!-- Optional: IMU sensor for balance control --\x3e\n    <sensor name="imu_sensor">\n      <state_interface name="orientation.x"/>\n      <state_interface name="orientation.y"/>\n      <state_interface name="orientation.z"/>\n      <state_interface name="orientation.w"/>\n      <state_interface name="angular_velocity.x"/>\n      <state_interface name="angular_velocity.y"/>\n      <state_interface name="angular_velocity.z"/>\n      <state_interface name="linear_acceleration.x"/>\n      <state_interface name="linear_acceleration.y"/>\n      <state_interface name="linear_acceleration.z"/>\n    </sensor>\n\n  </ros2_control>\n\n  \x3c!-- Gazebo plugin to load ros2_control --\x3e\n  <gazebo>\n    <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">\n      <robot_param>robot_description</robot_param>\n      <robot_param_node>robot_state_publisher</robot_param_node>\n      <parameters>$(find humanoid_control)/config/controllers.yaml</parameters>\n    </plugin>\n  </gazebo>\n\n</robot>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"controller-configuration-yaml",children:"Controller Configuration YAML"}),"\n",(0,t.jsxs)(n.p,{children:["Define controller parameters in ",(0,t.jsx)(n.code,{children:"config/controllers.yaml"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"controller_manager:\n  ros__parameters:\n    update_rate: 100  # Hz - control loop frequency\n\n    # List of controllers to load on startup\n    joint_state_broadcaster:\n      type: joint_state_broadcaster/JointStateBroadcaster\n\n    arm_position_controller:\n      type: position_controllers/JointGroupPositionController\n\n    arm_trajectory_controller:\n      type: joint_trajectory_controller/JointTrajectoryController\n\n# Joint state broadcaster: publishes /joint_states topic\njoint_state_broadcaster:\n  ros__parameters:\n    # No additional config needed - broadcasts all joints automatically\n\n# Arm position controller: simple position commands\narm_position_controller:\n  ros__parameters:\n    joints:\n      - left_shoulder_pitch\n      - left_shoulder_roll\n      - left_elbow\n      - right_shoulder_pitch\n      - right_shoulder_roll\n      - right_elbow\n\n    # Interface to command (position, velocity, or effort)\n    interface_name: position\n\n# Arm trajectory controller: smooth trajectory execution\narm_trajectory_controller:\n  ros__parameters:\n    joints:\n      - left_shoulder_pitch\n      - left_shoulder_roll\n      - left_elbow\n      - right_shoulder_pitch\n      - right_shoulder_roll\n      - right_elbow\n\n    # Command interface\n    command_interfaces:\n      - position\n\n    # State interfaces for feedback\n    state_interfaces:\n      - position\n      - velocity\n\n    # Constraints for trajectory execution\n    constraints:\n      stopped_velocity_tolerance: 0.01  # rad/s\n      goal_time: 0.5  # seconds - time tolerance for reaching goal\n\n    # PID gains for trajectory tracking (per joint)\n    gains:\n      left_shoulder_pitch: {p: 100.0, d: 10.0, i: 0.0, i_clamp: 1.0}\n      left_shoulder_roll: {p: 80.0, d: 8.0, i: 0.0, i_clamp: 1.0}\n      left_elbow: {p: 60.0, d: 6.0, i: 0.0, i_clamp: 1.0}\n      right_shoulder_pitch: {p: 100.0, d: 10.0, i: 0.0, i_clamp: 1.0}\n      right_shoulder_roll: {p: 80.0, d: 8.0, i: 0.0, i_clamp: 1.0}\n      right_elbow: {p: 60.0, d: 6.0, i: 0.0, i_clamp: 1.0}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"control-loop-basics",children:"Control Loop Basics"}),"\n",(0,t.jsxs)(n.p,{children:["The ros2_control control loop follows this sequence (executed at ",(0,t.jsx)(n.code,{children:"update_rate"}),", e.g., 100 Hz):"]}),"\n",(0,t.jsx)(n.h3,{id:"1-read-state",children:"1. Read State"}),"\n",(0,t.jsx)(n.p,{children:"Hardware interface reads current joint positions, velocities, and efforts from encoders/sensors."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Pseudocode - actual implementation in hardware plugin\nfor (auto& joint : joints_) {\n  joint.position = read_encoder(joint.name);\n  joint.velocity = compute_velocity(joint.position, previous_position, dt);\n  joint.effort = read_current_sensor(joint.name);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-update-controllers",children:"2. Update Controllers"}),"\n",(0,t.jsx)(n.p,{children:"Each active controller runs its control algorithm, reading state and computing commands."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// JointTrajectoryController update (simplified)\nfor (size_t i = 0; i < joints_.size(); ++i) {\n  // Get target position from trajectory at current time\n  double target_position = trajectory_.sample(current_time, i);\n\n  // PID control law\n  double error = target_position - joint_state_[i].position;\n  double error_derivative = -joint_state_[i].velocity;  // Assumes target velocity = 0\n\n  // Compute command (effort in this case)\n  joint_commands_[i].effort = gains_[i].p * error + gains_[i].d * error_derivative;\n\n  // Clamp to joint limits\n  joint_commands_[i].effort = std::clamp(\n    joint_commands_[i].effort,\n    -max_effort_[i],\n    max_effort_[i]\n  );\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-write-commands",children:"3. Write Commands"}),"\n",(0,t.jsx)(n.p,{children:"Hardware interface sends commands to actuators."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Pseudocode\nfor (auto& joint : joints_) {\n  write_motor_command(joint.name, joint.command_effort);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-repeat",children:"4. Repeat"}),"\n",(0,t.jsx)(n.p,{children:"Loop repeats at fixed rate. Real-time scheduling ensures deterministic timing."}),"\n",(0,t.jsx)(n.h2,{id:"launching-ros2_control-system",children:"Launching ros2_control System"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\"\"\"\nLaunch file for humanoid robot with ros2_control.\n\"\"\"\n\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\nfrom launch.actions import ExecuteProcess\nfrom ament_index_python.packages import get_package_share_directory\nimport os\n\ndef generate_launch_description():\n    # Get URDF file path\n    urdf_path = os.path.join(\n        get_package_share_directory('humanoid_description'),\n        'urdf',\n        'humanoid.urdf.xacro'\n    )\n\n    # Get controller config path\n    controller_config = os.path.join(\n        get_package_share_directory('humanoid_control'),\n        'config',\n        'controllers.yaml'\n    )\n\n    return LaunchDescription([\n        # Start Gazebo simulation\n        ExecuteProcess(\n            cmd=['gazebo', '--verbose', '-s', 'libgazebo_ros_factory.so'],\n            output='screen'\n        ),\n\n        # Spawn robot in Gazebo\n        Node(\n            package='gazebo_ros',\n            executable='spawn_entity.py',\n            arguments=['-entity', 'humanoid', '-topic', 'robot_description'],\n            output='screen'\n        ),\n\n        # Publish robot description\n        Node(\n            package='robot_state_publisher',\n            executable='robot_state_publisher',\n            parameters=[{'robot_description': open(urdf_path).read()}],\n            output='screen'\n        ),\n\n        # Load and start controller manager\n        Node(\n            package='controller_manager',\n            executable='ros2_control_node',\n            parameters=[controller_config],\n            output='screen'\n        ),\n\n        # Spawn controllers\n        ExecuteProcess(\n            cmd=['ros2', 'control', 'load_controller', '--set-state', 'active',\n                 'joint_state_broadcaster'],\n            output='screen'\n        ),\n\n        ExecuteProcess(\n            cmd=['ros2', 'control', 'load_controller', '--set-state', 'active',\n                 'arm_trajectory_controller'],\n            output='screen'\n        ),\n\n        # Launch RViz for visualization\n        Node(\n            package='rviz2',\n            executable='rviz2',\n            arguments=['-d', os.path.join(\n                get_package_share_directory('humanoid_description'),\n                'rviz',\n                'humanoid.rviz'\n            )],\n            output='screen'\n        ),\n    ])\n"})}),"\n",(0,t.jsx)(n.h2,{id:"testing-controllers",children:"Testing Controllers"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'# List available controllers\nros2 control list_controllers\n\n# Check controller status\nros2 control list_hardware_interfaces\n\n# Send position command to arm controller\nros2 topic pub /arm_position_controller/commands std_msgs/msg/Float64MultiArray \\\n  "{data: [0.5, 0.3, 1.2, -0.5, -0.3, -1.2]}"\n\n# Send trajectory to trajectory controller\nros2 action send_goal /arm_trajectory_controller/follow_joint_trajectory \\\n  control_msgs/action/FollowJointTrajectory \\\n  -f trajectory_goal.yaml\n'})}),"\n",(0,t.jsx)(n.h2,{id:"hardware-interfaces-for-real-robots",children:"Hardware Interfaces for Real Robots"}),"\n",(0,t.jsx)(n.p,{children:"For physical humanoid hardware, implement a custom hardware interface plugin:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include "hardware_interface/system_interface.hpp"\n\nclass HumanoidHardwareInterface : public hardware_interface::SystemInterface\n{\npublic:\n  // Initialize hardware (open serial ports, connect to motor controllers)\n  hardware_interface::CallbackReturn on_init(\n    const hardware_interface::HardwareInfo & info) override;\n\n  // Read joint states from encoders\n  hardware_interface::return_type read(\n    const rclcpp::Time & time, const rclcpp::Duration & period) override;\n\n  // Write commands to motors\n  hardware_interface::return_type write(\n    const rclcpp::Time & time, const rclcpp::Duration & period) override;\n\nprivate:\n  // Hardware communication (e.g., CAN bus, EtherCAT)\n  std::unique_ptr<MotorController> motor_controller_;\n\n  // Cached state/command values\n  std::vector<double> joint_positions_;\n  std::vector<double> joint_velocities_;\n  std::vector<double> joint_efforts_;\n  std::vector<double> joint_commands_;\n};\n'})}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.p,{children:["You now understand how ros2_control bridges simulation and hardware through standardized interfaces. The final chapter provides a ",(0,t.jsx)(n.strong,{children:"Complete URDF Example"})," with integrated ros2_control configuration\u2014a working humanoid robot ready for simulation in Gazebo."]}),"\n",(0,t.jsx)(n.h3,{id:"practice-exercise",children:"Practice Exercise"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Modify ",(0,t.jsx)(n.code,{children:"controllers.yaml"})," to create a ",(0,t.jsx)(n.code,{children:"leg_position_controller"})," for hip and knee joints"]}),"\n",(0,t.jsx)(n.li,{children:"Launch the system in Gazebo"}),"\n",(0,t.jsxs)(n.li,{children:["Send commands to move the legs using ",(0,t.jsx)(n.code,{children:"ros2 topic pub"})]}),"\n",(0,t.jsxs)(n.li,{children:["Monitor joint states with ",(0,t.jsx)(n.code,{children:"ros2 topic echo /joint_states"})]}),"\n",(0,t.jsx)(n.li,{children:"Tune PID gains to achieve smooth motion without oscillation"}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>a,x:()=>s});var r=o(6540);const t={},i=r.createContext(t);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);