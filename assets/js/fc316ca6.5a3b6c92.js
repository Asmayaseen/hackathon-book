"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[186],{1508:(n,e,a)=>{a.d(e,{A:()=>r});const r=a.p+"assets/images/ai-11-71168c92bad60825ac497d00716b9fa3.png"},3856:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module-03-isaac/week-10-nav2","title":"Week 10: Navigation with Nav2","description":"Navigation with Nav2","source":"@site/docs/module-03-isaac/week-10-nav2.md","sourceDirName":"module-03-isaac","slug":"/module-03-isaac/week-10-nav2","permalink":"/hackathon-book/module-03-isaac/week-10-nav2","draft":false,"unlisted":false,"editUrl":"https://github.com/Asmayaseen/hackathon-book/tree/main/frontend/docs/module-03-isaac/week-10-nav2.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Week 9: Perception for Manipulation","permalink":"/hackathon-book/module-03-isaac/week-9-perception"},"next":{"title":"Week 10: Bipedal Locomotion Control","permalink":"/hackathon-book/module-03-isaac/week-10-bipedal-locomotion"}}');var o=a(4848),i=a(8453);const t={},l="Week 10: Navigation with Nav2",s={},c=[{value:"Introduction to Nav2",id:"introduction-to-nav2",level:2},{value:"Nav2 Architecture",id:"nav2-architecture",level:2},{value:"Costmaps for Humanoid Navigation",id:"costmaps-for-humanoid-navigation",level:2},{value:"Key Differences from Wheeled Robots",id:"key-differences-from-wheeled-robots",level:3},{value:"Humanoid Costmap Configuration",id:"humanoid-costmap-configuration",level:3},{value:"Path Planning Algorithms",id:"path-planning-algorithms",level:2},{value:"Dijkstra vs. A*",id:"dijkstra-vs-a",level:3},{value:"Planner Configuration",id:"planner-configuration",level:3},{value:"Controller for Bipedal Motion",id:"controller-for-bipedal-motion",level:2},{value:"Bipedal-Specific Constraints",id:"bipedal-specific-constraints",level:3},{value:"Recovery Behaviors",id:"recovery-behaviors",level:2},{value:"Humanoid-Safe Recovery Sequence",id:"humanoid-safe-recovery-sequence",level:3},{value:"Launching Nav2 for Humanoid",id:"launching-nav2-for-humanoid",level:2},{value:"Exercises",id:"exercises",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"week-10-navigation-with-nav2",children:"Week 10: Navigation with Nav2"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.img,{alt:"Navigation with Nav2",src:a(1508).A+"",width:"736",height:"1313"})}),"\n",(0,o.jsx)(e.h2,{id:"introduction-to-nav2",children:"Introduction to Nav2"}),"\n",(0,o.jsxs)(e.p,{children:["Nav2 (Navigation2) is the ROS 2 navigation stack that enables autonomous robot movement. Originally designed for wheeled robots, Nav2 can be adapted for ",(0,o.jsx)(e.strong,{children:"bipedal humanoid navigation"})," with appropriate configuration."]}),"\n",(0,o.jsx)(e.h2,{id:"nav2-architecture",children:"Nav2 Architecture"}),"\n",(0,o.jsx)(e.p,{children:"Nav2 consists of modular components (servers) that work together:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Map Server"}),": Provides occupancy grid map (free space vs. obstacles)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"AMCL"}),": Adaptive Monte Carlo Localization for pose estimation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Planner Server"}),": Computes global path from start to goal"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Controller Server"}),": Generates velocity commands to follow the path"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Recovery Server"}),": Executes behaviors when navigation fails (spinning, backing up)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Behavior Tree Navigator"}),": Orchestrates the above components"]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"# Conceptual Nav2 pipeline\ndef navigate_to_goal(goal_pose):\n    # 1. Localize robot on map\n    current_pose = amcl.get_pose()\n\n    # 2. Plan global path\n    global_path = planner.make_plan(current_pose, goal_pose)\n\n    # 3. Follow path with local planning\n    while not at_goal:\n        local_plan = controller.compute_velocity_commands(global_path, current_pose)\n        robot.execute_velocity(local_plan)\n\n        # Handle obstacles\n        if path_blocked:\n            recovery.execute_recovery()\n"})}),"\n",(0,o.jsx)(e.h2,{id:"costmaps-for-humanoid-navigation",children:"Costmaps for Humanoid Navigation"}),"\n",(0,o.jsx)(e.p,{children:"Costmaps represent the environment as a grid where each cell has a cost (0 = free, 255 = obstacle). Humanoids require special considerations:"}),"\n",(0,o.jsx)(e.h3,{id:"key-differences-from-wheeled-robots",children:"Key Differences from Wheeled Robots"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Footprint Shape"}),": Rectangular footprint representing bipedal stance width"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Inflation Radius"}),": Smaller due to humanoid's ability to navigate tight spaces"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Height Clearance"}),": Must account for humanoid's tall vertical profile"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Dynamic Stability"}),": Cannot stop instantly - requires forward motion planning"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"humanoid-costmap-configuration",children:"Humanoid Costmap Configuration"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'# costmap_params.yaml - Configured for bipedal humanoid\nglobal_costmap:\n  global_frame: map\n  robot_base_frame: base_link\n  update_frequency: 5.0      # Hz - update global costmap\n  publish_frequency: 2.0\n\n  # Costmap size\n  width: 20                  # 20 meter x 20 meter map\n  height: 20\n  resolution: 0.05           # 5cm grid cells\n\n  # Humanoid footprint (30cm wide stance, 50cm long including step)\n  footprint: [\n    [0.25, 0.15],   # Front-right\n    [0.25, -0.15],  # Front-left\n    [-0.25, -0.15], # Back-left\n    [-0.25, 0.15]   # Back-right\n  ]\n\n  plugins: ["static_layer", "obstacle_layer", "inflation_layer"]\n\n  static_layer:\n    plugin: "nav2_costmap_2d::StaticLayer"\n    map_subscribe_transient_local: True\n\n  obstacle_layer:\n    plugin: "nav2_costmap_2d::ObstacleLayer"\n    observation_sources: scan lidar\n\n    # Use 2D lidar for ground-level obstacles\n    scan:\n      topic: /scan\n      max_obstacle_height: 2.0  # Detect obstacles up to 2m (humanoid height)\n      clearing_range: 5.0\n      raytrace_range: 6.0\n\n    # Use 3D lidar/camera for full environment perception\n    lidar:\n      topic: /points\n      max_obstacle_height: 2.5\n      min_obstacle_height: 0.1  # Ignore ground\n\n  inflation_layer:\n    plugin: "nav2_costmap_2d::InflationLayer"\n    cost_scaling_factor: 3.0\n    inflation_radius: 0.35  # Smaller than wheeled (humanoid agility)\n\n# Local costmap for dynamic obstacle avoidance\nlocal_costmap:\n  global_frame: odom\n  robot_base_frame: base_link\n  update_frequency: 10.0     # Higher update rate for reactive navigation\n  publish_frequency: 5.0\n\n  width: 5                   # 5m x 5m local window\n  height: 5\n  resolution: 0.05\n\n  footprint: [\n    [0.25, 0.15],\n    [0.25, -0.15],\n    [-0.25, -0.15],\n    [-0.25, 0.15]\n  ]\n\n  plugins: ["voxel_layer", "inflation_layer"]\n\n  voxel_layer:\n    plugin: "nav2_costmap_2d::VoxelLayer"\n    enabled: True\n    publish_voxel_map: True\n    origin_z: 0.0\n    z_resolution: 0.2        # 20cm vertical resolution\n    z_voxels: 10             # 2m height (10 * 0.2m)\n    max_obstacle_height: 2.0\n    mark_threshold: 2        # Cells with 2+ hits marked as obstacle\n'})}),"\n",(0,o.jsx)(e.h2,{id:"path-planning-algorithms",children:"Path Planning Algorithms"}),"\n",(0,o.jsxs)(e.p,{children:["Nav2 supports multiple global planners. Humanoids benefit from ",(0,o.jsx)(e.strong,{children:"Dijkstra"})," or ",(0,o.jsx)(e.strong,{children:"A"}),"* for stable, predictable paths."]}),"\n",(0,o.jsx)(e.h3,{id:"dijkstra-vs-a",children:"Dijkstra vs. A*"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"# Dijkstra: explores uniformly in all directions\ndef dijkstra(start, goal, costmap):\n    visited = set()\n    priority_queue = [(0, start)]  # (cost, node)\n\n    while priority_queue:\n        cost, current = heappop(priority_queue)\n        if current == goal:\n            return reconstruct_path(current)\n\n        for neighbor in get_neighbors(current, costmap):\n            new_cost = cost + costmap[neighbor]\n            if neighbor not in visited:\n                visited.add(neighbor)\n                heappush(priority_queue, (new_cost, neighbor))\n\n# A*: uses heuristic to guide search toward goal\ndef a_star(start, goal, costmap):\n    visited = set()\n    priority_queue = [(heuristic(start, goal), 0, start)]  # (f, g, node)\n\n    while priority_queue:\n        f, g, current = heappop(priority_queue)\n        if current == goal:\n            return reconstruct_path(current)\n\n        for neighbor in get_neighbors(current, costmap):\n            new_g = g + costmap[neighbor]\n            new_f = new_g + heuristic(neighbor, goal)  # f = g + h\n            if neighbor not in visited:\n                visited.add(neighbor)\n                heappush(priority_queue, (new_f, new_g, neighbor))\n\ndef heuristic(node, goal):\n    # Euclidean distance as heuristic\n    return sqrt((node.x - goal.x)**2 + (node.y - goal.y)**2)\n"})}),"\n",(0,o.jsx)(e.h3,{id:"planner-configuration",children:"Planner Configuration"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'# planner_server_params.yaml\nplanner_server:\n  ros__parameters:\n    expected_planner_frequency: 2.0  # Plan every 0.5s\n\n    plugins: ["GridBased"]\n\n    GridBased:\n      plugin: "nav2_navfn_planner/NavfnPlanner"  # A* implementation\n      tolerance: 0.1              # 10cm goal tolerance\n      use_astar: True             # Use A* (False = Dijkstra)\n      allow_unknown: False        # Don\'t plan through unexplored areas\n      use_final_approach_orientation: True  # Orient toward goal\n'})}),"\n",(0,o.jsx)(e.h2,{id:"controller-for-bipedal-motion",children:"Controller for Bipedal Motion"}),"\n",(0,o.jsxs)(e.p,{children:["The ",(0,o.jsx)(e.strong,{children:"DWB (Dynamic Window Approach) controller"})," generates velocity commands that respect kinodynamic constraints."]}),"\n",(0,o.jsx)(e.h3,{id:"bipedal-specific-constraints",children:"Bipedal-Specific Constraints"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'# controller_params.yaml\ncontroller_server:\n  ros__parameters:\n    controller_frequency: 20.0  # 20 Hz control loop\n\n    plugins: ["FollowPath"]\n\n    FollowPath:\n      plugin: "dwb_core::DWBLocalPlanner"\n\n      # Bipedal velocity limits (slower than wheeled robots)\n      min_vel_x: 0.1            # Must maintain forward motion for stability\n      max_vel_x: 0.5            # 0.5 m/s max walking speed\n      min_vel_y: -0.2           # Limited lateral movement\n      max_vel_y: 0.2\n      max_vel_theta: 0.3        # 0.3 rad/s turning speed\n\n      # Acceleration limits (gradual for balance)\n      acc_lim_x: 0.3            # 0.3 m/s\xb2 (gentle acceleration)\n      acc_lim_y: 0.2\n      acc_lim_theta: 0.5\n      decel_lim_x: -0.3         # Gentle deceleration\n\n      # Trajectory scoring\n      critics: [\n        "RotateToGoal",\n        "Oscillation",\n        "BaseObstacle",\n        "GoalAlign",\n        "PathAlign",\n        "PathDist",\n        "GoalDist"\n      ]\n\n      # Critic weights (tune for humanoid behavior)\n      PathAlign.scale: 32.0      # Strongly prefer following global path\n      GoalAlign.scale: 24.0      # Orient toward goal\n      PathDist.scale: 32.0\n      GoalDist.scale: 24.0\n      BaseObstacle.scale: 0.02   # Obstacle avoidance\n\n      # Simulation parameters\n      sim_time: 2.0              # Simulate trajectories 2 seconds ahead\n      vx_samples: 10             # Sample 10 velocities per dimension\n      vy_samples: 5\n      vtheta_samples: 10\n\n      # Trajectory constraints\n      trajectory_generator_name: "dwb_plugins::StandardTrajectoryGenerator"\n'})}),"\n",(0,o.jsx)(e.h2,{id:"recovery-behaviors",children:"Recovery Behaviors"}),"\n",(0,o.jsx)(e.p,{children:"When navigation fails, recovery behaviors attempt to get the robot unstuck."}),"\n",(0,o.jsx)(e.h3,{id:"humanoid-safe-recovery-sequence",children:"Humanoid-Safe Recovery Sequence"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'# behavior_tree_params.yaml\nbt_navigator:\n  ros__parameters:\n    plugin_lib_names:\n      - nav2_compute_path_to_pose_action_bt_node\n      - nav2_follow_path_action_bt_node\n      - nav2_back_up_action_bt_node\n      - nav2_spin_action_bt_node\n      - nav2_wait_action_bt_node\n\n    # Recovery behavior parameters\n    global_frame: map\n    robot_base_frame: base_link\n    transform_tolerance: 0.1\n\n    # Recovery sequence for humanoids (gentle, stable motions)\n    default_nav_through_poses_bt_xml: ""\n    default_nav_to_pose_bt_xml: ""\n\n    # Spin recovery - rotate in place to clear sensors\n    spin:\n      simulate_ahead_time: 2.0\n      max_rotational_vel: 0.2     # Slow rotation for stability\n      min_rotational_vel: 0.1\n      rotational_acc_lim: 0.3\n\n    # Backup recovery - step backward\n    backup:\n      simulate_ahead_time: 2.0\n      backup_dist: 0.3            # Small 30cm backup\n      backup_speed: 0.1           # Slow, controlled\n'})}),"\n",(0,o.jsx)(e.h2,{id:"launching-nav2-for-humanoid",children:"Launching Nav2 for Humanoid"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"# humanoid_nav2_launch.py\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\nfrom ament_index_python.packages import get_package_share_directory\nimport os\n\ndef generate_launch_description():\n    pkg_dir = get_package_share_directory('humanoid_navigation')\n\n    return LaunchDescription([\n        # Map server - load pre-built map\n        Node(\n            package='nav2_map_server',\n            executable='map_server',\n            name='map_server',\n            parameters=[{\n                'yaml_filename': os.path.join(pkg_dir, 'maps', 'office.yaml'),\n                'use_sim_time': False\n            }]\n        ),\n\n        # AMCL localization\n        Node(\n            package='nav2_amcl',\n            executable='amcl',\n            name='amcl',\n            parameters=[os.path.join(pkg_dir, 'config', 'amcl_params.yaml')]\n        ),\n\n        # Planner server\n        Node(\n            package='nav2_planner',\n            executable='planner_server',\n            name='planner_server',\n            parameters=[os.path.join(pkg_dir, 'config', 'planner_params.yaml')]\n        ),\n\n        # Controller server\n        Node(\n            package='nav2_controller',\n            executable='controller_server',\n            name='controller_server',\n            parameters=[os.path.join(pkg_dir, 'config', 'controller_params.yaml')]\n        ),\n\n        # Recovery server\n        Node(\n            package='nav2_recoveries',\n            executable='recoveries_server',\n            name='recoveries_server',\n            parameters=[os.path.join(pkg_dir, 'config', 'recovery_params.yaml')]\n        ),\n\n        # Behavior tree navigator\n        Node(\n            package='nav2_bt_navigator',\n            executable='bt_navigator',\n            name='bt_navigator',\n            parameters=[os.path.join(pkg_dir, 'config', 'bt_navigator_params.yaml')]\n        ),\n\n        # Lifecycle manager\n        Node(\n            package='nav2_lifecycle_manager',\n            executable='lifecycle_manager',\n            name='lifecycle_manager_navigation',\n            parameters=[{\n                'autostart': True,\n                'node_names': [\n                    'map_server',\n                    'amcl',\n                    'planner_server',\n                    'controller_server',\n                    'recoveries_server',\n                    'bt_navigator'\n                ]\n            }]\n        )\n    ])\n"})}),"\n",(0,o.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Costmap Tuning"}),": Adjust footprint and inflation radius for your simulated humanoid. Observe effects on path planning."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Algorithm Comparison"}),": Run navigation with Dijkstra and A* planners. Measure planning time and path length differences."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Recovery Testing"}),": Place the robot in a tight corner and trigger recovery behaviors. Observe which sequence successfully escapes."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Dynamic Obstacles"}),": Add moving obstacles to the environment and observe local planner's avoidance behavior."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Next"}),": ",(0,o.jsx)(e.a,{href:"/hackathon-book/module-03-isaac/week-10-bipedal-locomotion",children:"Week 10 - Bipedal Locomotion"})]})]})}function h(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453:(n,e,a)=>{a.d(e,{R:()=>t,x:()=>l});var r=a(6540);const o={},i=r.createContext(o);function t(n){const e=r.useContext(i);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:t(n.components),r.createElement(i.Provider,{value:e},n.children)}}}]);