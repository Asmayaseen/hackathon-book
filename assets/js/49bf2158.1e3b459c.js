"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[206],{2086:(e,n,r)=>{r.d(n,{A:()=>t});const t=r.p+"assets/images/ai-6-abcf4be7763f58bf15e987b6b05b86a7.png"},3450:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-01-ros2/week-4-services-actions","title":"Week 4: Services and Actions","description":"Services and Actions","source":"@site/docs/module-01-ros2/week-4-services-actions.md","sourceDirName":"module-01-ros2","slug":"/module-01-ros2/week-4-services-actions","permalink":"/hackathon-book/module-01-ros2/week-4-services-actions","draft":false,"unlisted":false,"editUrl":"https://github.com/Asmayaseen/hackathon-book/tree/main/frontend/docs/module-01-ros2/week-4-services-actions.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Week 3: Nodes and Topics","permalink":"/hackathon-book/module-01-ros2/week-3-nodes-topics"},"next":{"title":"Week 5: URDF for Humanoid Robots","permalink":"/hackathon-book/module-01-ros2/week-5-urdf"}}');var s=r(4848),a=r(8453);const i={},o="Week 4: Services and Actions",l={},c=[{value:"Service Client-Server Pattern",id:"service-client-server-pattern",level:2},{value:"When to Use Services",id:"when-to-use-services",level:3},{value:"Service Type Anatomy",id:"service-type-anatomy",level:3},{value:"Service Server Example: Inverse Kinematics Calculator",id:"service-server-example-inverse-kinematics-calculator",level:2},{value:"Service Client Example",id:"service-client-example",level:2},{value:"Action Servers: Long-Running Tasks",id:"action-servers-long-running-tasks",level:2},{value:"Action Structure",id:"action-structure",level:3},{value:"Action Server Example: Walk to Position",id:"action-server-example-walk-to-position",level:2},{value:"Parameters and Dynamic Reconfigure",id:"parameters-and-dynamic-reconfigure",level:2},{value:"Using Parameters from CLI",id:"using-parameters-from-cli",level:3},{value:"Next Steps",id:"next-steps",level:2},{value:"Practice Exercise",id:"practice-exercise",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"week-4-services-and-actions",children:"Week 4: Services and Actions"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Services and Actions",src:r(2086).A+"",width:"736",height:"736"})}),"\n",(0,s.jsx)(n.h2,{id:"service-client-server-pattern",children:"Service Client-Server Pattern"}),"\n",(0,s.jsx)(n.p,{children:"While topics enable continuous data streaming, many robot operations require request-response interactions. Services provide synchronous RPC (Remote Procedure Call) semantics: a client sends a request and blocks until receiving a response from the server."}),"\n",(0,s.jsx)(n.h3,{id:"when-to-use-services",children:"When to Use Services"}),"\n",(0,s.jsx)(n.p,{children:"Services are ideal for:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Infrequent queries"}),": Computing inverse kinematics for a target pose"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Configuration changes"}),": Setting controller gains or switching operational modes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State queries"}),": Requesting current battery level or system diagnostics"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Atomic operations"}),": Triggering calibration sequences that must complete before returning"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Critical distinction"}),": Services block the calling node until complete. Never use services for operations that take more than ~1 second\u2014use actions instead (covered below)."]}),"\n",(0,s.jsx)(n.h3,{id:"service-type-anatomy",children:"Service Type Anatomy"}),"\n",(0,s.jsxs)(n.p,{children:["Services consist of a request message and a response message. Example: ",(0,s.jsx)(n.code,{children:"AddTwoInts.srv"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"# Request\nint64 a\nint64 b\n---\n# Response\nint64 sum\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"---"})," separator divides request from response. For humanoid robotics, common service types include:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"SetBool"}),": Enable/disable a controller"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Trigger"}),": Initiate calibration or homing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"GetPose"}),": Query end-effector position"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"service-server-example-inverse-kinematics-calculator",children:"Service Server Example: Inverse Kinematics Calculator"}),"\n",(0,s.jsx)(n.p,{children:"This server computes joint angles needed to position a humanoid's hand at a target location\u2014a fundamental operation for manipulation tasks."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\"\"\"\nInverse kinematics service for humanoid arm.\nComputes joint angles to reach target end-effector pose.\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.srv import GetPlan\nfrom geometry_msgs.msg import Pose, Point, Quaternion\nfrom sensor_msgs.msg import JointState\nimport math\n\nclass IKService(Node):\n    \"\"\"\n    Provides inverse kinematics solving as a service.\n    Simplified 2-DOF arm for demonstration.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('ik_service')\n\n        # Create service server on /compute_ik topic\n        # Service type: custom message defined in package\n        self.srv = self.create_service(\n            GetPlan,  # Reusing existing type for demonstration\n            'compute_ik',\n            self.compute_ik_callback\n        )\n\n        # Arm parameters (meters)\n        self.upper_arm_length = 0.3  # Shoulder to elbow\n        self.forearm_length = 0.25   # Elbow to wrist\n\n        self.get_logger().info('IK service ready')\n\n    def compute_ik_callback(self, request, response):\n        \"\"\"\n        Solve inverse kinematics for 2-DOF planar arm.\n\n        Args:\n            request: Contains target pose (position and orientation)\n            response: Populated with joint angles\n\n        Returns:\n            response: Modified response object (ROS 2 convention)\n        \"\"\"\n        # Extract target position from request\n        target_x = request.goal.pose.position.x\n        target_y = request.goal.pose.position.y\n\n        self.get_logger().info(f'IK request: target=({target_x:.3f}, {target_y:.3f})')\n\n        # Calculate distance to target\n        distance = math.sqrt(target_x**2 + target_y**2)\n\n        # Check if target is reachable\n        max_reach = self.upper_arm_length + self.forearm_length\n        min_reach = abs(self.upper_arm_length - self.forearm_length)\n\n        if distance > max_reach or distance < min_reach:\n            self.get_logger().error(\n                f'Target unreachable: distance={distance:.3f}m, '\n                f'valid range=[{min_reach:.3f}, {max_reach:.3f}]'\n            )\n            # Return empty response to indicate failure\n            return response\n\n        # Compute elbow angle using law of cosines\n        # c\xb2 = a\xb2 + b\xb2 - 2ab*cos(C)\n        cos_elbow = (\n            (target_x**2 + target_y**2 -\n             self.upper_arm_length**2 - self.forearm_length**2) /\n            (2 * self.upper_arm_length * self.forearm_length)\n        )\n\n        # Clamp to [-1, 1] to avoid numerical errors\n        cos_elbow = max(-1.0, min(1.0, cos_elbow))\n        elbow_angle = math.acos(cos_elbow)\n\n        # Compute shoulder angle\n        alpha = math.atan2(target_y, target_x)\n        beta = math.atan2(\n            self.forearm_length * math.sin(elbow_angle),\n            self.upper_arm_length + self.forearm_length * math.cos(elbow_angle)\n        )\n        shoulder_angle = alpha - beta\n\n        # Populate response (in production, return JointState message)\n        self.get_logger().info(\n            f'IK solution: shoulder={math.degrees(shoulder_angle):.1f}\xb0, '\n            f'elbow={math.degrees(elbow_angle):.1f}\xb0'\n        )\n\n        # For demonstration, encode angles in response\n        # In real implementation, define custom service type with JointState response\n        response.plan.poses = []  # Placeholder\n\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = IKService()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info('Shutting down IK service')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"service-client-example",children:"Service Client Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nClient that requests inverse kinematics solutions.\n"""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.srv import GetPlan\nfrom geometry_msgs.msg import PoseStamped, Point\n\nclass IKClient(Node):\n    def __init__(self):\n        super().__init__(\'ik_client\')\n\n        # Create service client\n        self.client = self.create_client(GetPlan, \'compute_ik\')\n\n        # Wait for service to become available (with 5 second timeout)\n        self.get_logger().info(\'Waiting for IK service...\')\n        if not self.client.wait_for_service(timeout_sec=5.0):\n            self.get_logger().error(\'IK service not available\')\n            return\n\n        self.get_logger().info(\'IK service connected\')\n\n    def send_request(self, x, y):\n        """\n        Send IK request for target position.\n\n        Args:\n            x (float): Target x coordinate (meters)\n            y (float): Target y coordinate (meters)\n        """\n        # Create request message\n        request = GetPlan.Request()\n        request.goal = PoseStamped()\n        request.goal.pose.position = Point(x=x, y=y, z=0.0)\n\n        # Send request asynchronously (non-blocking)\n        future = self.client.call_async(request)\n\n        # Register callback for when response arrives\n        future.add_done_callback(self.handle_response)\n\n    def handle_response(self, future):\n        """\n        Called when service response is received.\n\n        Args:\n            future: Future object containing response\n        """\n        try:\n            response = future.result()\n            self.get_logger().info(\'IK solution received\')\n            # Process response.plan data here\n        except Exception as e:\n            self.get_logger().error(f\'Service call failed: {e}\')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    client = IKClient()\n\n    # Request IK for position (0.4, 0.3)\n    client.send_request(0.4, 0.3)\n\n    # Spin to process callbacks\n    rclpy.spin(client)\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,s.jsx)(n.h2,{id:"action-servers-long-running-tasks",children:"Action Servers: Long-Running Tasks"}),"\n",(0,s.jsx)(n.p,{children:"Actions extend services for operations that take significant time (seconds to minutes) and require progress feedback. Examples include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Walking to a destination (report distance remaining)"}),"\n",(0,s.jsx)(n.li,{children:"Grasping an object (report contact forces during approach)"}),"\n",(0,s.jsx)(n.li,{children:"Standup sequence (report completion of each phase)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"action-structure",children:"Action Structure"}),"\n",(0,s.jsx)(n.p,{children:"Actions have three components:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Goal"}),": Request message (e.g., target position for walking)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Result"}),": Final outcome (e.g., success/failure, final pose)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Feedback"}),": Periodic progress updates (e.g., current distance to goal)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Actions also support ",(0,s.jsx)(n.strong,{children:"cancellation"}),"\u2014critical for safety when a humanoid must abort a motion."]}),"\n",(0,s.jsx)(n.h2,{id:"action-server-example-walk-to-position",children:"Action Server Example: Walk to Position"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\"\"\"\nAction server for humanoid walking.\nExecutes walk commands with progress feedback.\n\"\"\"\n\nimport rclpy\nfrom rclpy.action import ActionServer\nfrom rclpy.node import Node\nfrom action_msgs.msg import GoalStatus\n# In production, define custom action: WalkToPosition.action\n# For demo, using example action type\nfrom example_interfaces.action import Fibonacci\nimport time\n\nclass WalkActionServer(Node):\n    \"\"\"\n    Executes walking motions as long-running actions.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('walk_action_server')\n\n        # Create action server\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,  # Replace with custom WalkToPosition action\n            'walk_to_position',\n            self.execute_callback\n        )\n\n        # Walking parameters\n        self.walking_speed = 0.5  # m/s\n\n        self.get_logger().info('Walk action server started')\n\n    def execute_callback(self, goal_handle):\n        \"\"\"\n        Execute walking action.\n\n        Args:\n            goal_handle: Handle for managing action execution\n\n        Returns:\n            Result message\n        \"\"\"\n        self.get_logger().info('Executing walk action')\n\n        # Extract goal (in real action, this would be target pose)\n        target_distance = 2.0  # meters\n        steps_required = int(target_distance / self.walking_speed)\n\n        # Create feedback message\n        feedback_msg = Fibonacci.Feedback()\n\n        # Simulate walking with periodic feedback\n        for step in range(steps_required):\n            # Check if cancellation requested\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info('Walk action canceled')\n                return Fibonacci.Result()\n\n            # Compute progress\n            distance_covered = step * self.walking_speed\n            distance_remaining = target_distance - distance_covered\n\n            # Publish feedback (in real implementation, include current pose)\n            feedback_msg.sequence = [int(distance_covered * 100), int(distance_remaining * 100)]\n            goal_handle.publish_feedback(feedback_msg)\n\n            self.get_logger().info(\n                f'Walking: {distance_covered:.2f}m covered, '\n                f'{distance_remaining:.2f}m remaining'\n            )\n\n            # Simulate one second of walking\n            time.sleep(1.0)\n\n        # Mark action as succeeded\n        goal_handle.succeed()\n\n        # Return result\n        result = Fibonacci.Result()\n        result.sequence = [int(target_distance * 100)]\n        self.get_logger().info(f'Walk completed: {target_distance}m')\n\n        return result\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = WalkActionServer()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info('Shutting down walk action server')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"parameters-and-dynamic-reconfigure",children:"Parameters and Dynamic Reconfigure"}),"\n",(0,s.jsx)(n.p,{children:"Parameters allow runtime configuration without restarting nodes\u2014essential for tuning controller gains during testing."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\"\"\"\nDemonstrates ROS 2 parameter usage for controller tuning.\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rcl_interfaces.msg import SetParametersResult\n\nclass BalanceController(Node):\n    def __init__(self):\n        super().__init__('balance_controller')\n\n        # Declare parameters with default values\n        self.declare_parameter('kp_pitch', 50.0)   # Proportional gain for pitch\n        self.declare_parameter('kd_pitch', 10.0)   # Derivative gain\n        self.declare_parameter('kp_roll', 50.0)\n        self.declare_parameter('kd_roll', 10.0)\n        self.declare_parameter('max_torque', 100.0)  # Nm\n\n        # Register callback for parameter changes\n        self.add_on_set_parameters_callback(self.parameter_callback)\n\n        # Read initial parameter values\n        self.update_gains()\n\n        self.get_logger().info(\n            f'Balance controller initialized: '\n            f'kp_pitch={self.kp_pitch}, kd_pitch={self.kd_pitch}'\n        )\n\n    def update_gains(self):\n        \"\"\"Read current parameter values.\"\"\"\n        self.kp_pitch = self.get_parameter('kp_pitch').value\n        self.kd_pitch = self.get_parameter('kd_pitch').value\n        self.kp_roll = self.get_parameter('kp_roll').value\n        self.kd_roll = self.get_parameter('kd_roll').value\n        self.max_torque = self.get_parameter('max_torque').value\n\n    def parameter_callback(self, params):\n        \"\"\"\n        Called when parameters are changed via CLI or service.\n\n        Args:\n            params: List of parameters being modified\n\n        Returns:\n            SetParametersResult: Success/failure indicator\n        \"\"\"\n        for param in params:\n            self.get_logger().info(f'Parameter changed: {param.name} = {param.value}')\n\n        # Update internal gains\n        self.update_gains()\n\n        # Validate parameters (example: ensure gains are positive)\n        if self.kp_pitch < 0 or self.kd_pitch < 0:\n            self.get_logger().error('Gains must be positive')\n            return SetParametersResult(successful=False)\n\n        return SetParametersResult(successful=True)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = BalanceController()\n    rclpy.spin(node)\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"using-parameters-from-cli",children:"Using Parameters from CLI"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Get current parameter values\nros2 param get /balance_controller kp_pitch\n\n# Set new value (triggers callback)\nros2 param set /balance_controller kp_pitch 75.0\n\n# List all parameters for a node\nros2 param list /balance_controller\n\n# Save parameters to YAML file\nros2 param dump /balance_controller > controller_params.yaml\n\n# Load parameters from file on startup\nros2 run humanoid_control balance_controller --ros-args --params-file controller_params.yaml\n"})}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.p,{children:["You now understand services for request-response operations, actions for long-running tasks with feedback, and parameters for runtime configuration. The next chapter, ",(0,s.jsx)(n.strong,{children:"Week 5: URDF"}),", introduces robot modeling\u2014defining the kinematic structure of a humanoid robot for simulation and control."]}),"\n",(0,s.jsx)(n.h3,{id:"practice-exercise",children:"Practice Exercise"}),"\n",(0,s.jsx)(n.p,{children:"Create an action client that:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Sends a walk goal to the action server"}),"\n",(0,s.jsx)(n.li,{children:"Displays progress feedback in the terminal"}),"\n",(0,s.jsx)(n.li,{children:"Cancels the action if user presses 'q'"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Hint: Use ",(0,s.jsx)(n.code,{children:"rclpy.action.ActionClient"})," and register callbacks for feedback, result, and goal_response."]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var t=r(6540);const s={},a=t.createContext(s);function i(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);