"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[327],{703:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"module-02-simulation/week-6-gazebo-basics","title":"Week 6: Gazebo Basics","description":"Installation and Setup","source":"@site/docs/module-02-simulation/week-6-gazebo-basics.md","sourceDirName":"module-02-simulation","slug":"/module-02-simulation/week-6-gazebo-basics","permalink":"/hackathon-book/module-02-simulation/week-6-gazebo-basics","draft":false,"unlisted":false,"editUrl":"https://github.com/Asmayaseen/hackathon-book/tree/main/frontend/docs/module-02-simulation/week-6-gazebo-basics.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Module 2: Gazebo & Unity Simulation","permalink":"/hackathon-book/module-02-simulation/intro"},"next":{"title":"Week 6: Physics Configuration for Humanoid Robots","permalink":"/hackathon-book/module-02-simulation/week-6-physics"}}');var o=i(4848),t=i(8453);const l={},r="Week 6: Gazebo Basics",a={},d=[{value:"Installation and Setup",id:"installation-and-setup",level:2},{value:"SDF Models: The Robot Description Language",id:"sdf-models-the-robot-description-language",level:2},{value:"Physics Engines: ODE vs Bullet",id:"physics-engines-ode-vs-bullet",level:2},{value:"ODE (Open Dynamics Engine)",id:"ode-open-dynamics-engine",level:3},{value:"Bullet",id:"bullet",level:3},{value:"Spawning Robots and Running Simulation",id:"spawning-robots-and-running-simulation",level:2}];function c(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"week-6-gazebo-basics",children:"Week 6: Gazebo Basics"})}),"\n",(0,o.jsx)(e.h2,{id:"installation-and-setup",children:"Installation and Setup"}),"\n",(0,o.jsxs)(e.p,{children:["Gazebo integrates tightly with ROS2. We'll use ",(0,o.jsx)(e.strong,{children:"Gazebo Fortress"})," (formerly Ignition Gazebo), the modern replacement for Gazebo Classic."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Install Gazebo Fortress on Ubuntu 22.04\nsudo apt-get update\nsudo apt-get install -y gazebo-fortress\n\n# Verify installation\nign gazebo --version\n# Expected output: Gazebo Fortress 6.x.x\n\n# Install ROS2 Gazebo bridge for Humble\nsudo apt-get install ros-humble-ros-gz-bridge ros-humble-ros-gz-sim\n"})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Key Difference"}),": Gazebo Classic used ",(0,o.jsx)(e.code,{children:"gazebo"})," commands; Ignition/Fortress uses ",(0,o.jsx)(e.code,{children:"ign gazebo"}),"."]}),"\n",(0,o.jsx)(e.h2,{id:"sdf-models-the-robot-description-language",children:"SDF Models: The Robot Description Language"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"SDF (Simulation Description Format)"})," is XML-based and more expressive than URDF. Unlike URDF (designed for kinematics), SDF natively supports:"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Closed kinematic loops"}),"\n",(0,o.jsx)(e.li,{children:"Multiple models in one file"}),"\n",(0,o.jsx)(e.li,{children:"Plugin configurations for sensors and controllers"}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Example"}),": Simple humanoid torso with two arms (simplified for clarity)."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- humanoid_torso.sdf --\x3e\n<?xml version="1.0"?>\n<sdf version="1.8">\n  <model name="humanoid_torso">\n    \x3c!-- Base link (torso) --\x3e\n    <link name="torso">\n      <pose>0 0 1.0 0 0 0</pose> \x3c!-- x y z roll pitch yaw --\x3e\n      <inertial>\n        <mass>15.0</mass> \x3c!-- 15 kg torso --\x3e\n        <inertia>\n          <ixx>0.5</ixx> <ixy>0</ixy> <ixz>0</ixz>\n          <iyy>0.6</iyy> <iyz>0</iyz> <izz>0.3</izz>\n        </inertia>\n      </inertial>\n      <collision name="torso_collision">\n        <geometry>\n          <box><size>0.3 0.4 0.6</size></box> \x3c!-- Width Depth Height --\x3e\n        </geometry>\n      </collision>\n      <visual name="torso_visual">\n        <geometry>\n          <box><size>0.3 0.4 0.6</size></box>\n        </geometry>\n        <material>\n          <ambient>0.2 0.2 0.8 1</ambient> \x3c!-- Blue torso --\x3e\n        </material>\n      </visual>\n    </link>\n\n    \x3c!-- Right shoulder joint --\x3e\n    <joint name="right_shoulder" type="revolute">\n      <parent>torso</parent>\n      <child>right_upper_arm</child>\n      <axis>\n        <xyz>1 0 0</xyz> \x3c!-- Rotate around X-axis (pitch) --\x3e\n        <limit>\n          <lower>-1.57</lower> \x3c!-- -90 degrees --\x3e\n          <upper>1.57</upper>  \x3c!-- +90 degrees --\x3e\n          <effort>50</effort>   \x3c!-- Max torque: 50 Nm --\x3e\n          <velocity>2.0</velocity> \x3c!-- Max speed: 2 rad/s --\x3e\n        </limit>\n      </axis>\n    </joint>\n\n    \x3c!-- Right upper arm link --\x3e\n    <link name="right_upper_arm">\n      <pose relative_to="right_shoulder">0 -0.25 0 0 0 0</pose>\n      <inertial>\n        <mass>2.0</mass>\n        <inertia>\n          <ixx>0.01</ixx> <ixy>0</ixy> <ixz>0</ixz>\n          <iyy>0.01</iyy> <iyz>0</iyz> <izz>0.005</izz>\n        </inertia>\n      </inertial>\n      <collision name="arm_collision">\n        <geometry>\n          <cylinder><radius>0.05</radius><length>0.3</length></cylinder>\n        </geometry>\n      </collision>\n      <visual name="arm_visual">\n        <geometry>\n          <cylinder><radius>0.05</radius><length>0.3</length></cylinder>\n        </geometry>\n      </visual>\n    </link>\n  </model>\n</sdf>\n'})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Key Concepts"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"<pose>"}),": Position (x, y, z) and orientation (roll, pitch, yaw in radians)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"<inertial>"}),": Mass and moment of inertia tensor (critical for stable simulation)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"relative_to"}),": Child link positions relative to parent joint frame"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"physics-engines-ode-vs-bullet",children:"Physics Engines: ODE vs Bullet"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo supports multiple physics engines. The two most common for humanoid robotics are:"}),"\n",(0,o.jsx)(e.h3,{id:"ode-open-dynamics-engine",children:"ODE (Open Dynamics Engine)"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Pros"}),": Fast, handles large contact counts well"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Cons"}),': Less accurate contact resolution, can be "bouncy"']}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Best For"}),": Multi-legged robots, rough terrain navigation"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"bullet",children:"Bullet"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Pros"}),": Accurate collision detection, stable stacking"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Cons"}),": Slower for many contacts"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Best For"}),": Manipulation tasks, precise contact modeling"]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"World File Configuration"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- world_file.sdf --\x3e\n<?xml version="1.0"?>\n<sdf version="1.8">\n  <world name="humanoid_world">\n    \x3c!-- Choose physics engine: ode, bullet, dart --\x3e\n    <physics name="default_physics" type="bullet">\n      <max_step_size>0.001</max_step_size> \x3c!-- 1ms timestep --\x3e\n      <real_time_factor>1.0</real_time_factor> \x3c!-- Run at real-time speed --\x3e\n      <real_time_update_rate>1000</real_time_update_rate> \x3c!-- 1000 Hz --\x3e\n    </physics>\n\n    \x3c!-- Lighting for visualization --\x3e\n    <light name="sun" type="directional">\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n    </light>\n\n    \x3c!-- Ground plane --\x3e\n    <model name="ground">\n      <static>true</static>\n      <link name="ground_link">\n        <collision name="ground_collision">\n          <geometry>\n            <plane><normal>0 0 1</normal></plane>\n          </geometry>\n          <surface>\n            <friction>\n              <ode><mu>1.0</mu></ode> \x3c!-- Friction coefficient --\x3e\n            </friction>\n          </surface>\n        </collision>\n      </link>\n    </model>\n\n    \x3c!-- Include our humanoid model --\x3e\n    <include>\n      <uri>file://humanoid_torso.sdf</uri>\n      <pose>0 0 1.5 0 0 0</pose> \x3c!-- Spawn 1.5m above ground --\x3e\n    </include>\n  </world>\n</sdf>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"spawning-robots-and-running-simulation",children:"Spawning Robots and Running Simulation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Launch Gazebo with the world file\nign gazebo world_file.sdf\n\n# Alternative: Spawn model dynamically via command\nign service -s /world/humanoid_world/create \\\n  --reqtype ignition.msgs.EntityFactory \\\n  --reptype ignition.msgs.Boolean \\\n  --timeout 1000 \\\n  --req 'sdf_filename: \"humanoid_torso.sdf\", pose: {position: {z: 2.0}}'\n"})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Exercise"}),": Modify ",(0,o.jsx)(e.code,{children:"humanoid_torso.sdf"})," to add a left arm (mirror the right arm). Adjust inertia values and verify the robot doesn't tip over when spawned."]}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Next"}),": ",(0,o.jsx)(e.a,{href:"/hackathon-book/module-02-simulation/week-6-physics",children:"Week 6 - Physics Configuration"})," - Tuning collision, friction, and contact forces for realistic humanoid behavior."]})]})}function u(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(c,{...n})}):c(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>r});var s=i(6540);const o={},t=s.createContext(o);function l(n){const e=s.useContext(t);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:l(n.components),s.createElement(t.Provider,{value:e},n.children)}}}]);