"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[3252],{6070:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-03-isaac/week-10-bipedal-locomotion","title":"Week 10: Bipedal Locomotion Control","description":"The Bipedal Stability Challenge","source":"@site/docs/module-03-isaac/week-10-bipedal-locomotion.md","sourceDirName":"module-03-isaac","slug":"/module-03-isaac/week-10-bipedal-locomotion","permalink":"/hackathon-book/module-03-isaac/week-10-bipedal-locomotion","draft":false,"unlisted":false,"editUrl":"https://github.com/Asmayaseen/hackathon-book/tree/main/frontend/docs/module-03-isaac/week-10-bipedal-locomotion.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Week 10: Navigation with Nav2","permalink":"/hackathon-book/module-03-isaac/week-10-nav2"},"next":{"title":"Module 4: Vision-Language-Action Integration","permalink":"/hackathon-book/module-04-vla/intro"}}');var r=t(4848),i=t(8453);const a={},s="Week 10: Bipedal Locomotion Control",l={},c=[{value:"The Bipedal Stability Challenge",id:"the-bipedal-stability-challenge",level:2},{value:"Key Challenges",id:"key-challenges",level:3},{value:"Zero Moment Point (ZMP) Criterion",id:"zero-moment-point-zmp-criterion",level:2},{value:"Mathematical Definition",id:"mathematical-definition",level:3},{value:"Gait Generation",id:"gait-generation",level:2},{value:"Simple Gait Trajectory Generator",id:"simple-gait-trajectory-generator",level:3},{value:"Balance Control",id:"balance-control",level:2},{value:"PID Balance Controller",id:"pid-balance-controller",level:3},{value:"Integration with Nav2",id:"integration-with-nav2",level:2},{value:"Exercises",id:"exercises",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"week-10-bipedal-locomotion-control",children:"Week 10: Bipedal Locomotion Control"})}),"\n",(0,r.jsx)(n.h2,{id:"the-bipedal-stability-challenge",children:"The Bipedal Stability Challenge"}),"\n",(0,r.jsxs)(n.p,{children:["Walking on two legs is fundamentally unstable. Unlike wheeled robots with static stability (they remain upright when stopped), humanoids must ",(0,r.jsx)(n.strong,{children:"dynamically balance"})," - constantly adjusting to prevent falling."]}),"\n",(0,r.jsx)(n.h3,{id:"key-challenges",children:"Key Challenges"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Small Support Polygon"}),": Feet provide minimal contact area compared to wheeled bases"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"High Center of Mass"}),": Humanoid torso is tall, creating large toppling moments"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Underactuation"}),": Fewer actuators than degrees of freedom (cannot directly control all motion)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Phase Transitions"}),": Switching between single-leg and double-leg support is discontinuous"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"zero-moment-point-zmp-criterion",children:"Zero Moment Point (ZMP) Criterion"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"Zero Moment Point"})," is the point on the ground where the sum of gravitational and inertial forces produces zero moment (torque). For stable walking, the ZMP must remain inside the ",(0,r.jsx)(n.strong,{children:"support polygon"})," (the convex hull of foot contact points)."]}),"\n",(0,r.jsx)(n.h3,{id:"mathematical-definition",children:"Mathematical Definition"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import numpy as np\n\ndef compute_zmp(robot_state):\n    \"\"\"\n    Compute Zero Moment Point from robot's state.\n\n    Args:\n        robot_state: Dictionary with keys:\n            - 'com_pos': Center of mass position [x, y, z]\n            - 'com_vel': Center of mass velocity [vx, vy, vz]\n            - 'com_acc': Center of mass acceleration [ax, ay, az]\n            - 'mass': Total robot mass (kg)\n\n    Returns:\n        zmp: [x, y] coordinates of ZMP on ground plane\n    \"\"\"\n    g = 9.81  # Gravity acceleration (m/s\xb2)\n\n    # Extract state\n    x, y, z = robot_state['com_pos']\n    vx, vy, vz = robot_state['com_vel']\n    ax, ay, az = robot_state['com_acc']\n    m = robot_state['mass']\n\n    # ZMP equations (assuming ground at z=0)\n    # ZMP_x = x - z * (ax + g*\u03b8_y) / (az + g)\n    # ZMP_y = y - z * (ay - g*\u03b8_x) / (az + g)\n    # Simplified for small angles:\n    zmp_x = x - z * ax / (az + g)\n    zmp_y = y - z * ay / (az + g)\n\n    return np.array([zmp_x, zmp_y])\n\ndef is_stable(zmp, support_polygon):\n    \"\"\"\n    Check if ZMP is inside support polygon.\n\n    Args:\n        zmp: [x, y] ZMP coordinates\n        support_polygon: List of [x, y] points defining foot contacts\n\n    Returns:\n        stable: True if ZMP inside polygon (stable)\n    \"\"\"\n    from shapely.geometry import Point, Polygon\n\n    zmp_point = Point(zmp)\n    support = Polygon(support_polygon)\n\n    return support.contains(zmp_point)\n\n# Example usage\nrobot_state = {\n    'com_pos': [0.0, 0.0, 0.8],      # CoM at 80cm height\n    'com_vel': [0.3, 0.0, 0.0],      # Walking forward at 0.3 m/s\n    'com_acc': [0.1, 0.0, -0.5],     # Accelerating forward\n    'mass': 45.0                      # 45kg humanoid\n}\n\nzmp = compute_zmp(robot_state)\nprint(f\"ZMP position: ({zmp[0]:.3f}, {zmp[1]:.3f})\")\n\n# Support polygon during single-leg stance (right foot)\nright_foot_polygon = [\n    [0.05, 0.05],   # Front-right corner\n    [0.05, -0.05],  # Front-left corner\n    [-0.05, -0.05], # Back-left corner\n    [-0.05, 0.05]   # Back-right corner\n]\n\nstable = is_stable(zmp, right_foot_polygon)\nprint(f\"Robot is {'STABLE' if stable else 'UNSTABLE'}\")\n"})}),"\n",(0,r.jsx)(n.h2,{id:"gait-generation",children:"Gait Generation"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"gait"})," is a coordinated pattern of leg movements. Humanoid walking typically uses a periodic gait with four phases:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Double Support"}),": Both feet on ground (stable but slow)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Left Swing"}),": Right foot supports, left foot moves forward"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Double Support"}),": Both feet on ground (transition)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Right Swing"}),": Left foot supports, right foot moves forward"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"simple-gait-trajectory-generator",children:"Simple Gait Trajectory Generator"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import numpy as np\n\nclass BipedGaitGenerator:\n    def __init__(self, step_length=0.15, step_height=0.05, step_duration=0.8):\n        """\n        Initialize bipedal gait generator.\n\n        Args:\n            step_length: Forward distance per step (meters)\n            step_height: Maximum foot lift height (meters)\n            step_duration: Time for one step (seconds)\n        """\n        self.step_length = step_length\n        self.step_height = step_height\n        self.step_duration = step_duration\n        self.double_support_ratio = 0.2  # 20% of step in double support\n\n    def generate_foot_trajectory(self, t, foot=\'left\'):\n        """\n        Generate foot trajectory for swing phase.\n\n        Args:\n            t: Time within current step (0 to step_duration)\n            foot: \'left\' or \'right\'\n\n        Returns:\n            foot_pos: [x, y, z] position of foot\n        """\n        # Normalize time to [0, 1]\n        phase = t / self.step_duration\n\n        # Double support at beginning and end of step\n        ds_time = self.double_support_ratio\n\n        if phase < ds_time or phase > (1 - ds_time):\n            # Double support - foot on ground\n            return self._stance_position(foot)\n        else:\n            # Swing phase - foot in air\n            swing_phase = (phase - ds_time) / (1 - 2*ds_time)  # Normalize to [0, 1]\n\n            # Forward motion (linear)\n            x = self.step_length * swing_phase\n\n            # Lateral offset (feet separated by hip width)\n            y = 0.1 if foot == \'left\' else -0.1\n\n            # Vertical motion (parabolic arc for smooth lift/landing)\n            z = 4 * self.step_height * swing_phase * (1 - swing_phase)\n\n            return np.array([x, y, z])\n\n    def _stance_position(self, foot):\n        """Return foot position during stance phase."""\n        y = 0.1 if foot == \'left\' else -0.1\n        return np.array([0.0, y, 0.0])\n\n    def generate_com_trajectory(self, t, num_steps):\n        """\n        Generate center of mass trajectory.\n        CoM shifts laterally over support foot during single support.\n\n        Args:\n            t: Current time\n            num_steps: Number of steps planned\n\n        Returns:\n            com_pos: [x, y, z] CoM position\n        """\n        # Forward velocity\n        vx = self.step_length / self.step_duration\n        com_x = vx * t\n\n        # Lateral shift (oscillate between left and right)\n        step_index = int(t / self.step_duration)\n        phase = (t % self.step_duration) / self.step_duration\n\n        # Shift CoM over support foot\n        if step_index % 2 == 0:\n            # Right foot support - shift CoM right\n            com_y = -0.05 * np.sin(np.pi * phase)\n        else:\n            # Left foot support - shift CoM left\n            com_y = 0.05 * np.sin(np.pi * phase)\n\n        # Constant height (simplified)\n        com_z = 0.8\n\n        return np.array([com_x, com_y, com_z])\n\n# Usage example\ngait = BipedGaitGenerator(step_length=0.15, step_height=0.05, step_duration=0.8)\n\n# Simulate one step\ndt = 0.01  # 100 Hz control\nfor t in np.arange(0, 0.8, dt):\n    left_foot = gait.generate_foot_trajectory(t, foot=\'left\')\n    right_foot = gait.generate_foot_trajectory(t, foot=\'right\')\n    com = gait.generate_com_trajectory(t, num_steps=5)\n\n    # In real implementation, these would be sent to inverse kinematics\n    # to compute joint angles\n    if int(t / dt) % 10 == 0:  # Print every 0.1s\n        print(f"t={t:.2f}s  CoM: {com}  L_foot: {left_foot}  R_foot: {right_foot}")\n'})}),"\n",(0,r.jsx)(n.h2,{id:"balance-control",children:"Balance Control"}),"\n",(0,r.jsxs)(n.p,{children:["Maintaining balance requires ",(0,r.jsx)(n.strong,{children:"real-time feedback control"})," to correct for disturbances."]}),"\n",(0,r.jsx)(n.h3,{id:"pid-balance-controller",children:"PID Balance Controller"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class ZMPBalanceController:\n    def __init__(self, kp=0.5, ki=0.01, kd=0.1):\n        """\n        PID controller to keep ZMP inside support polygon.\n\n        Args:\n            kp, ki, kd: PID gains for position, integral, derivative control\n        """\n        self.kp = kp\n        self.ki = ki\n        self.kd = kd\n\n        # Controller state\n        self.zmp_error_integral = np.zeros(2)\n        self.prev_zmp_error = np.zeros(2)\n\n    def compute_correction(self, desired_zmp, actual_zmp, dt):\n        """\n        Compute CoM acceleration correction to achieve desired ZMP.\n\n        Args:\n            desired_zmp: Target ZMP position [x, y]\n            actual_zmp: Current ZMP position [x, y]\n            dt: Time step (seconds)\n\n        Returns:\n            com_acc_correction: [ax, ay] to add to CoM acceleration\n        """\n        # ZMP error\n        zmp_error = desired_zmp - actual_zmp\n\n        # Update integral\n        self.zmp_error_integral += zmp_error * dt\n\n        # Compute derivative\n        zmp_error_derivative = (zmp_error - self.prev_zmp_error) / dt\n        self.prev_zmp_error = zmp_error\n\n        # PID control law\n        correction = (\n            self.kp * zmp_error +\n            self.ki * self.zmp_error_integral +\n            self.kd * zmp_error_derivative\n        )\n\n        return correction\n\n# Usage in control loop\ncontroller = ZMPBalanceController(kp=0.5, ki=0.01, kd=0.1)\n\n# Simulated control loop\ndt = 0.01\ndesired_zmp = np.array([0.0, 0.0])  # Keep ZMP at center of foot\n\nfor i in range(100):\n    # Measure current state\n    actual_zmp = compute_zmp(robot_state)\n\n    # Compute correction\n    com_acc_correction = controller.compute_correction(desired_zmp, actual_zmp, dt)\n\n    # Apply correction to CoM acceleration\n    robot_state[\'com_acc\'][:2] += com_acc_correction\n\n    # Update robot state (simplified dynamics)\n    robot_state[\'com_vel\'] += robot_state[\'com_acc\'] * dt\n    robot_state[\'com_pos\'] += robot_state[\'com_vel\'] * dt\n\n    if i % 10 == 0:\n        print(f"ZMP error: {np.linalg.norm(desired_zmp - actual_zmp):.4f}m")\n'})}),"\n",(0,r.jsx)(n.h2,{id:"integration-with-nav2",children:"Integration with Nav2"}),"\n",(0,r.jsxs)(n.p,{children:["Connecting bipedal locomotion to Nav2 navigation requires a ",(0,r.jsx)(n.strong,{children:"velocity command interpreter"})," that converts Nav2's commanded velocities into gait parameters:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom std_msgs.msg import Float64MultiArray\n\nclass BipedalLocomotionNode(Node):\n    def __init__(self):\n        super().__init__(\'bipedal_locomotion\')\n\n        # Subscribe to Nav2 velocity commands\n        self.cmd_vel_sub = self.create_subscription(\n            Twist,\n            \'/cmd_vel\',\n            self.velocity_callback,\n            10\n        )\n\n        # Publish joint commands to robot\n        self.joint_pub = self.create_publisher(\n            Float64MultiArray,\n            \'/joint_commands\',\n            10\n        )\n\n        # Gait generator\n        self.gait = BipedGaitGenerator()\n        self.controller = ZMPBalanceController()\n\n        # Control loop at 100 Hz\n        self.timer = self.create_timer(0.01, self.control_loop)\n\n        self.target_vx = 0.0\n        self.target_vy = 0.0\n        self.target_omega = 0.0\n        self.time = 0.0\n\n    def velocity_callback(self, msg):\n        """Receive velocity commands from Nav2."""\n        self.target_vx = msg.linear.x\n        self.target_vy = msg.linear.y\n        self.target_omega = msg.angular.z\n\n        # Adjust gait parameters based on commanded velocity\n        self.gait.step_length = self.target_vx * self.gait.step_duration\n        self.gait.step_length = np.clip(self.gait.step_length, 0.0, 0.3)  # Max 30cm steps\n\n    def control_loop(self):\n        """Generate gait and balance control at 100 Hz."""\n        # Generate desired foot and CoM positions\n        left_foot = self.gait.generate_foot_trajectory(self.time, \'left\')\n        right_foot = self.gait.generate_foot_trajectory(self.time, \'right\')\n        com_ref = self.gait.generate_com_trajectory(self.time, num_steps=5)\n\n        # Balance control (simplified - real implementation needs full state)\n        desired_zmp = np.array([0.0, 0.0])  # Center of support foot\n        actual_zmp = np.array([0.0, 0.0])   # Would come from sensors\n        com_correction = self.controller.compute_correction(desired_zmp, actual_zmp, 0.01)\n\n        # TODO: Inverse kinematics to convert foot/CoM positions to joint angles\n        # joint_angles = inverse_kinematics(left_foot, right_foot, com_ref)\n\n        # Publish joint commands\n        # joint_msg = Float64MultiArray(data=joint_angles)\n        # self.joint_pub.publish(joint_msg)\n\n        self.time += 0.01\n\ndef main():\n    rclpy.init()\n    node = BipedalLocomotionNode()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n'})}),"\n",(0,r.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"ZMP Analysis"}),": Compute ZMP for a stationary humanoid with CoM at various lateral positions. Identify the stability boundary."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Gait Visualization"}),": Use matplotlib to plot foot and CoM trajectories over 5 steps. Verify that CoM shifts appropriately over support foot."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"PID Tuning"}),": Implement the ZMP balance controller and tune PID gains to minimize settling time while avoiding oscillations."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Nav2 Integration"}),": Connect your gait generator to Nav2 velocity commands. Test navigation to waypoints in simulation."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Congratulations!"})," You've completed Module 3: NVIDIA Isaac Platform. You now understand GPU-accelerated simulation, synthetic data generation, hardware-accelerated perception, and bipedal locomotion control - the core technologies enabling next-generation humanoid robots."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Next Module"}),": ",(0,r.jsx)(n.a,{href:"/hackathon-book/module-04-vla/intro",children:"Module 4 - Vision-Language-Action Models"})]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var o=t(6540);const r={},i=o.createContext(r);function a(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);