"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[54],{5852:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-02-simulation/week-7-worlds","title":"Week 7: Building Custom Simulation Worlds","description":"Why Custom Environments Matter","source":"@site/docs/module-02-simulation/week-7-worlds.md","sourceDirName":"module-02-simulation","slug":"/module-02-simulation/week-7-worlds","permalink":"/hackathon-book/module-02-simulation/week-7-worlds","draft":false,"unlisted":false,"editUrl":"https://github.com/Asmayaseen/hackathon-book/tree/main/frontend/docs/module-02-simulation/week-7-worlds.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Week 7: Unity for Robotics","permalink":"/hackathon-book/module-02-simulation/week-7-unity"},"next":{"title":"Module 3: NVIDIA Isaac Platform for Physical AI","permalink":"/hackathon-book/module-03-isaac/intro"}}');var t=i(4848),r=i(8453);const a={},o="Week 7: Building Custom Simulation Worlds",l={},c=[{value:"Why Custom Environments Matter",id:"why-custom-environments-matter",level:2},{value:"Gazebo: Building Procedural Terrains",id:"gazebo-building-procedural-terrains",level:2},{value:"Heightmap Terrains (DEM Data)",id:"heightmap-terrains-dem-data",level:3},{value:"Obstacles and Dynamic Objects",id:"obstacles-and-dynamic-objects",level:3},{value:"Unity: Realistic Indoor/Outdoor Scenes",id:"unity-realistic-indooroutdoor-scenes",level:2},{value:"Terrain Creation in Unity",id:"terrain-creation-in-unity",level:3},{value:"Stairs and Multi-Level Structures",id:"stairs-and-multi-level-structures",level:3},{value:"Lighting for Realistic Sim-to-Real",id:"lighting-for-realistic-sim-to-real",level:3},{value:"Domain Randomization Best Practices",id:"domain-randomization-best-practices",level:2},{value:"Testing Checklist for Custom Worlds",id:"testing-checklist-for-custom-worlds",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"week-7-building-custom-simulation-worlds",children:"Week 7: Building Custom Simulation Worlds"})}),"\n",(0,t.jsx)(e.h2,{id:"why-custom-environments-matter",children:"Why Custom Environments Matter"}),"\n",(0,t.jsx)(e.p,{children:"Generic flat-ground simulations fail to expose real-world challenges:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Terrain Variability"}),": Slopes, stairs, uneven surfaces test balance controllers"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Obstacles"}),": Narrow passages, dynamic objects validate collision avoidance"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Lighting Conditions"}),": Shadows, reflections affect vision-based policies"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Domain Randomization"}),": Varying physics/visuals improves sim-to-real transfer"]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Goal"}),": Create environments that challenge your robot and mirror deployment scenarios."]}),"\n",(0,t.jsx)(e.h2,{id:"gazebo-building-procedural-terrains",children:"Gazebo: Building Procedural Terrains"}),"\n",(0,t.jsx)(e.h3,{id:"heightmap-terrains-dem-data",children:"Heightmap Terrains (DEM Data)"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Heightmaps"})," use grayscale images to define terrain elevation (white=high, black=low)."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'\x3c!-- world_with_terrain.sdf --\x3e\n<sdf version="1.8">\n  <world name="outdoor_terrain">\n    <physics type="bullet">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n    </physics>\n\n    \x3c!-- Heightmap terrain from image --\x3e\n    <model name="terrain">\n      <static>true</static>\n      <link name="terrain_link">\n        <collision name="terrain_collision">\n          <geometry>\n            <heightmap>\n              <uri>file://terrain_heightmap.png</uri> \x3c!-- 512x512 grayscale PNG --\x3e\n              <size>100 100 10</size> \x3c!-- Width Depth MaxHeight (meters) --\x3e\n              <pos>0 0 0</pos>\n            </heightmap>\n          </geometry>\n          <surface>\n            <friction>\n              <ode><mu>0.8</mu></ode> \x3c!-- Dirt/grass friction --\x3e\n            </friction>\n          </surface>\n        </collision>\n\n        <visual name="terrain_visual">\n          <geometry>\n            <heightmap>\n              <uri>file://terrain_heightmap.png</uri>\n              <size>100 100 10</size>\n              <texture>\n                <diffuse>file://grass_texture.jpg</diffuse>\n                <normal>file://grass_normal.jpg</normal> \x3c!-- Normal map for detail --\x3e\n                <size>10</size> \x3c!-- Texture repeat every 10m --\x3e\n              </texture>\n            </heightmap>\n          </geometry>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Dynamic lighting (sun moves over time) --\x3e\n    <light name="sun" type="directional">\n      <pose>0 0 100 0 0 0</pose>\n      <diffuse>0.9 0.9 0.7 1</diffuse> \x3c!-- Warm daylight --\x3e\n      <specular>0.2 0.2 0.2 1</specular>\n      <direction>-0.5 0.1 -0.9</direction> \x3c!-- Angled sunlight --\x3e\n      <cast_shadows>true</cast_shadows> \x3c!-- Realistic shadows --\x3e\n    </light>\n  </world>\n</sdf>\n'})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Generate Heightmap with Python"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom PIL import Image\n\ndef generate_hilly_terrain(width=512, height=512, num_hills=20):\n    """\n    Create procedural hills using Gaussian blobs.\n    Args:\n        width, height: Image dimensions\n        num_hills: Number of random hills\n    Returns:\n        PIL Image (grayscale heightmap)\n    """\n    terrain = np.zeros((height, width), dtype=np.float32)\n\n    for _ in range(num_hills):\n        # Random hill center\n        cx = np.random.randint(0, width)\n        cy = np.random.randint(0, height)\n\n        # Random hill size and height\n        sigma = np.random.randint(20, 80)  # Width of hill\n        amplitude = np.random.uniform(0.3, 1.0)  # Height (0-1 scale)\n\n        # Create Gaussian hill\n        y, x = np.ogrid[:height, :width]\n        hill = amplitude * np.exp(-((x - cx)**2 + (y - cy)**2) / (2 * sigma**2))\n        terrain += hill\n\n    # Normalize to 0-255 (PNG grayscale range)\n    terrain = (terrain / terrain.max() * 255).astype(np.uint8)\n\n    # Save as PNG\n    img = Image.fromarray(terrain, mode=\'L\')\n    img.save(\'terrain_heightmap.png\')\n    print("Heightmap saved: terrain_heightmap.png")\n\n# Generate terrain\ngenerate_hilly_terrain()\n'})}),"\n",(0,t.jsx)(e.h3,{id:"obstacles-and-dynamic-objects",children:"Obstacles and Dynamic Objects"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Add dynamic obstacles (boxes that can be pushed) --\x3e\n<model name="obstacle_box_1">\n  <pose>5 3 0.5 0 0 0</pose>\n  <link name="box_link">\n    <inertial>\n      <mass>20.0</mass> \x3c!-- 20kg box (heavy enough to challenge robot) --\x3e\n      <inertia><ixx>0.67</ixx><iyy>0.67</iyy><izz>0.67</izz></inertia>\n    </inertial>\n    <collision name="box_collision">\n      <geometry>\n        <box><size>1.0 1.0 1.0</size></box>\n      </geometry>\n      <surface>\n        <friction><ode><mu>0.5</mu></ode></friction> \x3c!-- Cardboard on ground --\x3e\n      </surface>\n    </collision>\n    <visual name="box_visual">\n      <geometry><box><size>1.0 1.0 1.0</size></box></geometry>\n      <material>\n        <ambient>0.7 0.5 0.3 1</ambient> \x3c!-- Brown cardboard color --\x3e\n      </material>\n    </visual>\n  </link>\n</model>\n\n\x3c!-- Narrow doorway (0.8m wide - tight for humanoid) --\x3e\n<model name="doorway">\n  <static>true</static>\n  <pose>10 0 0 0 0 0</pose>\n\n  <link name="left_wall">\n    <pose>0 -2 1 0 0 0</pose>\n    <collision name="wall_collision">\n      <geometry><box><size>0.2 4 2</size></box></geometry>\n    </collision>\n    <visual name="wall_visual">\n      <geometry><box><size>0.2 4 2</size></box></geometry>\n    </visual>\n  </link>\n\n  <link name="right_wall">\n    <pose>0 2 1 0 0 0</pose>\n    <collision name="wall_collision">\n      <geometry><box><size>0.2 4 2</size></box></geometry>\n    </collision>\n    <visual name="wall_visual">\n      <geometry><box><size>0.2 4 2</size></box></geometry>\n    </visual>\n  </link>\n</model>\n'})}),"\n",(0,t.jsx)(e.h2,{id:"unity-realistic-indooroutdoor-scenes",children:"Unity: Realistic Indoor/Outdoor Scenes"}),"\n",(0,t.jsx)(e.h3,{id:"terrain-creation-in-unity",children:"Terrain Creation in Unity"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Terrain GameObject"}),": ",(0,t.jsx)(e.code,{children:"GameObject \u2192 3D Object \u2192 Terrain"})]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Sculpt with Brushes"}),":","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Raise/Lower"}),": Create hills and valleys"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Smooth"}),": Reduce sharp edges (important for stable foot contact)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Paint Textures"}),": Grass, dirt, gravel (multiple layers)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Programmatic Terrain Generation (C#)"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\n\npublic class ProceduralTerrain : MonoBehaviour\n{\n    public int resolution = 513; // Terrain resolution (power of 2 + 1)\n    public float scale = 20f;    // Perlin noise scale (larger = smoother hills)\n    public float heightMultiplier = 10f; // Max terrain height\n\n    void Start()\n    {\n        Terrain terrain = GetComponent<Terrain>();\n        TerrainData terrainData = terrain.terrainData;\n\n        // Set terrain size\n        terrainData.heightmapResolution = resolution;\n        terrainData.size = new Vector3(100, 20, 100); // Width, Height, Depth\n\n        // Generate height values using Perlin noise\n        float[,] heights = new float[resolution, resolution];\n\n        for (int y = 0; y < resolution; y++)\n        {\n            for (int x = 0; x < resolution; x++)\n            {\n                // Perlin noise coordinates\n                float xCoord = (float)x / resolution * scale;\n                float yCoord = (float)y / resolution * scale;\n\n                // Sample noise (0-1 range)\n                float height = Mathf.PerlinNoise(xCoord, yCoord);\n                heights[y, x] = height; // Unity uses [y, x] indexing\n            }\n        }\n\n        // Apply heights to terrain\n        terrainData.SetHeights(0, 0, heights);\n\n        Debug.Log("Procedural terrain generated!");\n    }\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Attach Script"}),": Add to Terrain GameObject, press Play to generate."]}),"\n",(0,t.jsx)(e.h3,{id:"stairs-and-multi-level-structures",children:"Stairs and Multi-Level Structures"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:'// Procedurally generate stairs (testing locomotion policies)\npublic class StairGenerator : MonoBehaviour\n{\n    public int numSteps = 10;\n    public float stepWidth = 1.0f;\n    public float stepDepth = 0.3f;\n    public float stepHeight = 0.15f; // 15cm rise (standard building code)\n\n    void Start()\n    {\n        for (int i = 0; i < numSteps; i++)\n        {\n            // Create step GameObject\n            GameObject step = GameObject.CreatePrimitive(PrimitiveType.Cube);\n            step.transform.parent = transform;\n\n            // Position step\n            step.transform.position = new Vector3(\n                0,\n                i * stepHeight,\n                i * stepDepth\n            );\n\n            // Scale to step dimensions\n            step.transform.localScale = new Vector3(stepWidth, stepHeight, stepDepth);\n\n            // Add friction (wood stairs)\n            var collider = step.GetComponent<BoxCollider>();\n            var material = new PhysicMaterial("StairMaterial");\n            material.dynamicFriction = 0.6f;\n            material.staticFriction = 0.7f;\n            collider.material = material;\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"lighting-for-realistic-sim-to-real",children:"Lighting for Realistic Sim-to-Real"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Key Principle"}),": Train vision policies under ",(0,t.jsx)(e.strong,{children:"varied lighting"})," to avoid overfitting to simulation conditions."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-csharp",children:"// Random lighting controller (domain randomization)\npublic class LightingRandomizer : MonoBehaviour\n{\n    public Light directionalLight; // Assign main sun light\n\n    void OnEpisodeBegin() // Called when RL episode resets\n    {\n        // Randomize sun angle (simulates different times of day)\n        float randomAngleX = Random.Range(30f, 70f); // Morning to afternoon\n        float randomAngleY = Random.Range(-30f, 30f); // East/West variation\n        directionalLight.transform.rotation = Quaternion.Euler(randomAngleX, randomAngleY, 0);\n\n        // Randomize light intensity\n        directionalLight.intensity = Random.Range(0.6f, 1.2f);\n\n        // Randomize color temperature (warm/cool lighting)\n        float colorTemp = Random.Range(0.8f, 1.0f);\n        directionalLight.color = new Color(1f, colorTemp, colorTemp * 0.9f);\n    }\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Additional Randomization"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Skybox"}),": Rotate to change sun position"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Fog"}),": Add atmospheric scattering (outdoor scenes)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Shadows"}),": Toggle quality (soft vs hard shadows)"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"domain-randomization-best-practices",children:"Domain Randomization Best Practices"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Physics Randomization"})," (per episode):"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"# Gazebo plugin to randomize physics (pseudo-code)\nimport random\n\nclass PhysicsRandomizer:\n    def on_episode_reset(self):\n        # Randomize gravity (\xb15%)\n        gravity = 9.81 * random.uniform(0.95, 1.05)\n\n        # Randomize ground friction (0.6 - 1.4)\n        friction = random.uniform(0.6, 1.4)\n\n        # Randomize link masses (\xb110%)\n        for link in robot.links:\n            original_mass = link.mass\n            link.mass = original_mass * random.uniform(0.9, 1.1)\n\n        # Randomize joint damping (\xb120%)\n        for joint in robot.joints:\n            joint.damping *= random.uniform(0.8, 1.2)\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Visual Randomization"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Material colors (RGB channels \xb130%)"}),"\n",(0,t.jsx)(e.li,{children:"Texture scales (0.5x - 2x)"}),"\n",(0,t.jsx)(e.li,{children:"Object sizes (\xb115%)"}),"\n",(0,t.jsx)(e.li,{children:"Camera exposure (\xb120%)"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Sensor Randomization"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"LiDAR noise stddev: 1-5cm"}),"\n",(0,t.jsx)(e.li,{children:"Camera latency: 10-50ms"}),"\n",(0,t.jsx)(e.li,{children:"IMU bias drift: \xb10.1 m/s\xb2"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"testing-checklist-for-custom-worlds",children:"Testing Checklist for Custom Worlds"}),"\n",(0,t.jsx)(e.p,{children:"Before training policies, verify:"}),"\n",(0,t.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Robot spawns in stable pose (not sinking/floating)"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Collision geometry matches visual (no invisible walls)"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Friction values are realistic (robot doesn't slip excessively)"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Lighting doesn't cause rendering artifacts (shadow acne, z-fighting)"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Domain randomization ranges don't break physics (e.g., negative mass)"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Sensors receive data at expected rates (check topic frequencies)"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Performance: Simulation runs at \u22650.5x real-time speed"]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Exercise"}),": Create a Gazebo world with:"]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Heightmap terrain (at least 3 hills)"}),"\n",(0,t.jsx)(e.li,{children:"Staircase (8-10 steps, 15cm rise)"}),"\n",(0,t.jsx)(e.li,{children:"3 dynamic boxes (obstacles)"}),"\n",(0,t.jsx)(e.li,{children:"Narrow corridor (0.9m wide)"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Spawn a humanoid robot and manually control it (keyboard teleop) to navigate the environment. Document which obstacles cause the robot to fall or get stuck."}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Module 2 Summary"}),": You've learned to simulate humanoid robots in Gazebo and Unity, configure realistic physics, model sensors with noise, and build challenging environments. ",(0,t.jsx)(e.strong,{children:"Next Module"}),": ",(0,t.jsx)(e.a,{href:"/hackathon-book/module-03-isaac/intro",children:"Isaac Sim & Gym"})," - GPU-accelerated simulation for massive parallel training."]})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>o});var s=i(6540);const t={},r=s.createContext(t);function a(n){const e=s.useContext(r);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),s.createElement(r.Provider,{value:e},n.children)}}}]);